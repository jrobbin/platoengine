/*
//@HEADER
// *************************************************************************
//   Plato Engine v.1.0: Copyright 2018, National Technology & Engineering
//                    Solutions of Sandia, LLC (NTESS).
//
// Under the terms of Contract DE-NA0003525 with NTESS,
// the U.S. Government retains certain rights in this software.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the Sandia Corporation nor the names of the
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Questions? Contact the Plato team (plato3D-help@sandia.gov)
//
// *************************************************************************
//@HEADER
*/

/*
 * Plato_Test_Statistics.cpp
 *
 *  Created on: Nov 17, 2017
 */

#include "gtest/gtest.h"

#include <cmath>
#include <numeric>
#include <vector>

#include "Plato_DataFactory.hpp"
#include "Plato_Diagnostics.hpp"
#include "Plato_SromObjective.hpp"
#include "Plato_Communication.hpp"
#include "Plato_SromConstraint.hpp"
#include "Plato_SromStatistics.hpp"
#include "Plato_StandardVector.hpp"
#include "Plato_BetaDistribution.hpp"
#include "Plato_NormalDistribution.hpp"
#include "Plato_StandardMultiVector.hpp"
#include "Plato_UniformDistribution.hpp"
#include "Plato_TrustRegionAlgorithmDataMng.hpp"
#include "Plato_AugmentedLagrangianStageMng.hpp"
#include "Plato_KelleySachsAugmentedLagrangian.hpp"
#include "Plato_StandardVectorReductionOperations.hpp"
#include "Plato_StatisticsUtils.hpp"
#include "Plato_SolveUncertaintyProblem.hpp"

#include "Plato_UnitTestUtils.hpp"

namespace PlatoTest
{

template<typename ScalarType, typename OrdinalType>
void compute_srom_cdf_plot(const Plato::Vector<ScalarType, OrdinalType>& aSamplesMC,
                           const Plato::Vector<ScalarType, OrdinalType>& aSamplesSROM,
                           const Plato::Vector<ScalarType, OrdinalType>& aProbsSROM,
                           Plato::Vector<ScalarType, OrdinalType>& aSromCDF,
                           ScalarType aSigma = 1e-7)
{
    assert(aSromCDF.size() == aSamplesMC.size());
    assert(aSamplesSROM.size() == aProbsSROM.size());

    const ScalarType tConstant = std::sqrt(2);
    const OrdinalType tNumSamplesMC = aSamplesMC.size();
    const OrdinalType tNumSamplesSROM = aSamplesSROM.size();

    for(OrdinalType tIndexMC = 0; tIndexMC < tNumSamplesMC; tIndexMC++)
    {
        ScalarType tSum = 0;
        for(OrdinalType tIndexSROM = 0; tIndexSROM < tNumSamplesSROM; tIndexSROM++)
        {
            ScalarType tArg = (aSamplesMC[tIndexMC] - aSamplesSROM[tIndexSROM]) / (aSigma * tConstant);
            tSum = tSum
                    + aProbsSROM[tIndexSROM]
                            * (static_cast<ScalarType>(0.5) * (static_cast<ScalarType>(1) + erf(tArg)));
        }
        aSromCDF[tIndexMC] = tSum;
    }
}

std::vector<double> get_gold_beta_cdf_values()
{
    std::vector<double> tOutput = {0, 4.18251442858886e-06, 1.87360421565357e-05, 4.50004817470168e-05, 8.37385628098157e-05,
                                 0.000135489125083890, 0.000200664497540694, 0.000279594196842754, 0.000372548742159945,
                                 0.000479754207990887, 0.000601401828383970, 0.000737654698373451, 0.000888652652285164,
                                 0.0010545159353949, 0.0012353480430474, 0.0014312379655670, 0.0016422619969607,
                                 0.0018684852156916, 0.0021099627138546, 0.0023667406298788, 0.0026388570254160,
                                 0.0029263426369642, 0.0032292215255588, 0.0035475116426084, 0.0038812253260747,
                                 0.0042303697382715, 0.0045949472543414, 0.0049749558087518, 0.0053703892058213,
                                 0.0057812373992300, 0.0062074867446354, 0.0066491202288407, 0.0071061176784202,
                                 0.0075784559502643, 0.0080661091061408, 0.0085690485730724, 0.0090872432910760,
                                 0.0096206598496042, 0.0101692626138522, 0.0107330138419441, 0.0113118737938878,
                                 0.0119058008330800, 0.0125147515210493, 0.0131386807060482, 0.0137775416060337,
                                 0.0144312858865201, 0.0150998637337326, 0.0157832239234475, 0.0164813138858653,
                                 0.0171940797668256, 0.0179214664856470, 0.0186634177898433, 0.0194198763069473,
                                 0.0201907835936486, 0.0209760801824377, 0.0217757056259266, 0.0225895985390054,
                                 0.0234176966389782, 0.0242599367838101, 0.0251162550086087, 0.0259865865604479,
                                 0.0268708659316408, 0.0277690268915517, 0.0286810025170388, 0.0296067252216053,
                                 0.0305461267833346, 0.0314991383716788, 0.0324656905731647, 0.0334457134160766,
                                 0.0344391363941720, 0.0354458884894811, 0.0364658981942390, 0.0374990935319951,
                                 0.0385454020779416, 0.0396047509785003, 0.0406770669702058, 0.0417622763979169,
                                 0.0428603052323908, 0.0439710790872496, 0.0450945232353673, 0.0462305626247043,
                                 0.0473791218936146, 0.0485401253856494, 0.0497134971638795, 0.0508991610247576,
                                 0.0520970405115398, 0.0533070589272867, 0.0545291393474593, 0.0557632046321292,
                                 0.0570091774378179, 0.0582669802289787, 0.0595365352891390, 0.0608177647317126,
                                 0.0621105905104987, 0.0634149344298757, 0.0647307181547056, 0.0660578632199570,
                                 0.0673962910400583, 0.0687459229179908, 0.0701066800541325, 0.0714784835548588,
                                 0.0728612544409122, 0.0742549136555464, 0.0756593820724541, 0.0770745805034867,
                                 0.0785004297061699, 0.0799368503910264, 0.0813837632287094, 0.0828410888569527,
                                 0.0843087478873464, 0.0857866609119410, 0.0872747485096862, 0.0887729312527112,
                                 0.0902811297124489, 0.0917992644656111, 0.0933272561000183, 0.0948650252202884,
                                 0.0964124924533898, 0.0979695784540612, 0.0995362039101028, 0.101112289547545, 0.102697756135692,
                                 0.104292524492053, 0.105896515487156, 0.107509650049252, 0.109131849168908, 0.110763033903503,
                                 0.112403125381615, 0.114052044807313, 0.115709713464348, 0.117376052720258, 0.119050984030377,
                                 0.120734428941751, 0.122426309096979, 0.124126546237957, 0.125835062209552, 0.127551778963186,
                                 0.129276618560347, 0.131009503176028, 0.132750355102082, 0.134499096750512, 0.136255650656693,
                                 0.138019939482516, 0.139791886019477, 0.141571413191687, 0.143358444058831, 0.145152901819058,
                                 0.146954709811810, 0.148763791520594, 0.150580070575697, 0.152403470756838, 0.154233915995772,
                                 0.156071330378838, 0.157915638149450, 0.159766763710540, 0.161624631626952, 0.163489166627780,
                                 0.165360293608667, 0.167237937634046, 0.169122023939344, 0.171012477933137, 0.172909225199258,
                                 0.174812191498863, 0.176721302772462, 0.178636485141894, 0.180557664912273, 0.182484768573893,
                                 0.184417722804083, 0.186356454469039, 0.188300890625610, 0.190250958523044, 0.192206585604706,
                                 0.194167699509757, 0.196134228074796, 0.198106099335472, 0.200083241528059, 0.202065583091002,
                                 0.204053052666428, 0.206045579101625, 0.208043091450496, 0.210045518974973, 0.212052791146411,
                                 0.214064837646945, 0.216081588370824, 0.218102973425713, 0.220128923133971, 0.222159368033895,
                                 0.224194238880950, 0.226233466648958, 0.228276982531271, 0.230324717941916, 0.232376604516716,
                                 0.234432574114383, 0.236492558817594, 0.238556490934035, 0.240624302997429, 0.242695927768537,
                                 0.244771298236141, 0.246850347617997, 0.248933009361776, 0.251019217145975, 0.253108904880816,
                                 0.255202006709116, 0.257298457007142, 0.259398190385444, 0.261501141689669, 0.263607246001355,
                                 0.265716438638709, 0.267828655157361, 0.269943831351106, 0.272061903252622, 0.274182807134171,
                                 0.276306479508291, 0.278432857128458, 0.280561876989737, 0.282693476329420, 0.284827592627644,
                                 0.286964163607986, 0.289103127238058, 0.291244421730069, 0.293387985541384, 0.295533757375063,
                                 0.297681676180381, 0.299831681153343, 0.301983711737173, 0.304137707622802, 0.306293608749324,
                                 0.308451355304457, 0.310610887724975, 0.312772146697140, 0.314935073157104, 0.317099608291315,
                                 0.319265693536898, 0.321433270582030, 0.323602281366297, 0.325772668081043, 0.327944373169705,
                                 0.330117339328134, 0.332291509504909, 0.334466826901632, 0.336643234973217, 0.338820677428169,
                                 0.340999098228843, 0.343178441591701, 0.345358651987555, 0.347539674141794, 0.349721453034609,
                                 0.351903933901203, 0.354087062231988, 0.356270783772774, 0.358455044524953, 0.360639790745662,
                                 0.362824968947948, 0.365010525900910, 0.367196408629847, 0.369382564416382, 0.371568940798586,
                                 0.373755485571087, 0.375942146785173, 0.378128872748887, 0.380315612027109, 0.382502313441630,
                                 0.384688926071222, 0.386875399251695, 0.389061682575945, 0.391247725893994, 0.393433479313026,
                                 0.395618893197410, 0.397803918168714, 0.399988505105716, 0.402172605144404, 0.404356169677968,
                                 0.406539150356783, 0.408721499088391, 0.410903168037463, 0.413084109625771, 0.415264276532131,
                                 0.417443621692362, 0.419622098299219, 0.421799659802326, 0.423976259908105, 0.426151852579697,
                                 0.428326392036866, 0.430499832755915, 0.432672129469576, 0.434843237166907, 0.437013111093172,
                                 0.439181706749731, 0.441348979893899, 0.443514886538821, 0.445679382953331, 0.447842425661803,
                                 0.450003971443998, 0.452163977334912, 0.454322400624602, 0.456479198858022, 0.458634329834848,
                                 0.460787751609291, 0.462939422489909, 0.465089301039420, 0.467237346074496, 0.469383516665562,
                                 0.471527772136585, 0.473670072064855, 0.475810376280772, 0.477948644867612, 0.480084838161299,
                                 0.482218916750167, 0.484350841474718, 0.486480573427377, 0.488608073952239, 0.490733304644808,
                                 0.492856227351742, 0.494976804170580, 0.497094997449474, 0.499210769786911, 0.501324084031433,
                                 0.503434903281347, 0.505543190884443, 0.507648910437687, 0.509752025786932, 0.511852501026611,
                                 0.513950300499424, 0.516045388796027, 0.518137730754720, 0.520227291461116, 0.522314036247826,
                                 0.524397930694119, 0.526478940625590, 0.528557032113829, 0.530632171476068, 0.532704325274840,
                                 0.534773460317628, 0.536839543656510, 0.538902542587800, 0.540962424651686, 0.543019157631864,
                                 0.545072709555166, 0.547123048691190, 0.549170143551918, 0.551213962891340, 0.553254475705062,
                                 0.555291651229923, 0.557325458943602, 0.559355868564222, 0.561382850049947, 0.563406373598585,
                                 0.565426409647180, 0.567442928871598, 0.569455902186122, 0.571465300743029, 0.573471095932172,
                                 0.575473259380560, 0.577471762951929, 0.579466578746312, 0.581457679099606, 0.583445036583144,
                                 0.585428624003244, 0.587408414400772, 0.589384381050706, 0.591356497461671, 0.593324737375501,
                                 0.595289074766778, 0.597249483842382, 0.599205939041023, 0.601158415032781, 0.603106886718644,
                                 0.605051329230035, 0.606991717928344, 0.608928028404446, 0.610860236478239, 0.612788318198147,
                                 0.614712249840653, 0.616632007909804, 0.618547569136724, 0.620458910479130, 0.622366009120833,
                                 0.624268842471248, 0.626167388164889, 0.628061624060874, 0.629951528242420, 0.631837079016337,
                                 0.633718254912521, 0.635595034683445, 0.637467397303641, 0.639335321969191, 0.641198788097204,
                                 0.643057775325302, 0.644912263511091, 0.646762232731643, 0.648607663282964, 0.650448535679468,
                                 0.652284830653443, 0.654116529154522, 0.655943612349142, 0.657766061620012, 0.659583858565566,
                                 0.661396984999426, 0.663205422949857, 0.665009154659219, 0.666808162583422, 0.668602429391370,
                                 0.670391937964414, 0.672176671395793, 0.673956612990084, 0.675731746262635, 0.677502054939012,
                                 0.679267522954433, 0.681028134453204, 0.682783873788155, 0.684534725520068, 0.686280674417114,
                                 0.688021705454273, 0.689757803812766, 0.691488954879479, 0.693215144246386, 0.694936357709966,
                                 0.696652581270630, 0.698363801132132, 0.700070003700987, 0.701771175585890, 0.703467303597120,
                                 0.705158374745956, 0.706844376244087, 0.708525295503017, 0.710201120133474, 0.711871837944811,
                                 0.713537436944411, 0.715197905337087, 0.716853231524483, 0.718503404104474, 0.720148411870556,
                                 0.721788243811249, 0.723422889109486, 0.725052337142005, 0.726676577478743, 0.728295599882221,
                                 0.729909394306938, 0.731517950898750, 0.733121259994259, 0.734719312120198, 0.736312097992810,
                                 0.737899608517231, 0.739481834786868, 0.741058768082778, 0.742630399873047, 0.744196721812162,
                                 0.745757725740386, 0.747313403683134, 0.748863747850342, 0.750408750635837, 0.751948404616709,
                                 0.753482702552675, 0.755011637385453, 0.756535202238117, 0.758053390414472, 0.759566195398411,
                                 0.761073610853278, 0.762575630621231, 0.764072248722600, 0.765563459355246, 0.767049256893920,
                                 0.768529635889617, 0.770004591068934, 0.771474117333423, 0.772938209758944, 0.774396863595016,
                                 0.775850074264174, 0.777297837361311, 0.778740148653034, 0.780177004077009, 0.781608399741306,
                                 0.783034331923750, 0.784454797071264, 0.785869791799212, 0.787279312890744, 0.788683357296140,
                                 0.790081922132145, 0.791475004681318, 0.792862602391366, 0.794244712874483, 0.795621333906692,
                                 0.796992463427176, 0.798358099537621, 0.799718240501546, 0.801072884743637, 0.802422030849086,
                                 0.803765677562919, 0.805103823789332, 0.806436468591017, 0.807763611188496, 0.809085250959452,
                                 0.810401387438055, 0.811712020314289, 0.813017149433286, 0.814316774794644, 0.815610896551760,
                                 0.816899515011153, 0.818182630631785, 0.819460244024392, 0.820732355950799, 0.821998967323249,
                                 0.823260079203724, 0.824515692803262, 0.825765809481280, 0.827010430744898, 0.828249558248250,
                                 0.829483193791810, 0.830711339321707, 0.831933996929040, 0.833151168849202, 0.834362857461189,
                                 0.835569065286918, 0.836769794990545, 0.837965049377777, 0.839154831395185, 0.840339144129520,
                                 0.841517990807025, 0.842691374792750, 0.843859299589856, 0.845021768838938, 0.846178786317328,
                                 0.847330355938406, 0.848476481750914, 0.849617167938262, 0.850752418817840, 0.851882238840325,
                                 0.853006632588987, 0.854125604779004, 0.855239160256761, 0.856347303999163, 0.857450041112938,
                                 0.858547376833945, 0.859639316526482, 0.860725865682585, 0.861807029921340, 0.862882814988184,
                                 0.863953226754211, 0.865018271215474, 0.866077954492290, 0.867132282828546, 0.868181262590997,
                                 0.869224900268571, 0.870263202471673, 0.871296175931485, 0.872323827499270, 0.873346164145671,
                                 0.874363192960013, 0.875374921149607, 0.876381356039047, 0.877382505069511, 0.878378375798065,
                                 0.879368975896958, 0.880354313152926, 0.881334395466489, 0.882309230851251, 0.883278827433202,
                                 0.884243193450012, 0.885202337250333, 0.886156267293099, 0.887104992146822, 0.888048520488889,
                                 0.888986861104865, 0.889920022887787, 0.890848014837465, 0.891770846059775, 0.892688525765963,
                                 0.893601063271938, 0.894508467997569, 0.895410749465986, 0.896307917302876, 0.897199981235778,
                                 0.898086951093382, 0.898968836804824, 0.899845648398988, 0.900717396003797, 0.901584089845511,
                                 0.902445740248028, 0.903302357632175, 0.904153952515010, 0.905000535509114, 0.905842117321891,
                                 0.906678708754863, 0.907510320702968, 0.908336964153854, 0.909158650187182, 0.909975389973913,
                                 0.910787194775613, 0.911594075943748, 0.912396044918977, 0.913193113230453, 0.913985292495120,
                                 0.914772594417007, 0.915555030786527, 0.916332613479775, 0.917105354457822, 0.917873265766016,
                                 0.918636359533279, 0.919394647971403, 0.920148143374346, 0.920896858117536, 0.921640804657161,
                                 0.922379995529474, 0.923114443350087, 0.923844160813271, 0.924569160691254, 0.925289455833519,
                                 0.926005059166106, 0.926715983690906, 0.927422242484964, 0.928123848699779, 0.928820815560599,
                                 0.929513156365725, 0.930200884485811, 0.930884013363162, 0.931562556511034, 0.932236527512938,
                                 0.932905940021939, 0.933570807759957, 0.934231144517068, 0.934886964150808, 0.935538280585473,
                                 0.936185107811420, 0.936827459884373, 0.937465350924724, 0.938098795116835, 0.938727806708344,
                                 0.939352400009466, 0.939972589392298, 0.940588389290126, 0.941199814196724, 0.941806878665667,
                                 0.942409597309626, 0.943007984799685, 0.943602055864638, 0.944191825290300, 0.944777307918814,
                                 0.945358518647955, 0.945935472430441, 0.946508184273241, 0.947076669236878, 0.947640942434745,
                                 0.948201019032411, 0.948756914246928, 0.949308643346146, 0.949856221648021, 0.950399664519925,
                                 0.950938987377958, 0.951474205686262, 0.952005334956329, 0.952532390746318, 0.953055388660367,
                                 0.953574344347903, 0.954089273502962, 0.954600191863501, 0.955107115210712, 0.955610059368340,
                                 0.956109040201996, 0.956604073618478, 0.957095175565085, 0.957582362028937, 0.958065649036291,
                                 0.958545052651862, 0.959020588978141, 0.959492274154716, 0.959960124357593, 0.960424155798516,
                                 0.960884384724288, 0.961340827416097, 0.961793500188834, 0.962242419390422, 0.962687601401135,
                                 0.963129062632926, 0.963566819528752, 0.964000888561901, 0.964431286235314, 0.964858029080920,
                                 0.965281133658956, 0.965700616557303, 0.966116494390810, 0.966528783800627, 0.966937501453535,
                                 0.967342664041276, 0.967744288279889, 0.968142390909038, 0.968536988691350, 0.968928098411745,
                                 0.969315736876776, 0.969699920913959, 0.970080667371116, 0.970457993115707, 0.970831915034170,
                                 0.971202450031261, 0.971569615029392, 0.971933426967972, 0.972293902802746, 0.972651059505143,
                                 0.973004914061612, 0.973355483472970, 0.973702784753743, 0.974046834931515, 0.974387651046273,
                                 0.974725250149750, 0.975059649304779, 0.975390865584639, 0.975718916072402, 0.976043817860287,
                                 0.976365588049011, 0.976684243747139, 0.976999802070439, 0.977312280141235, 0.977621695087763,
                                 0.977928064043526, 0.978231404146651, 0.978531732539246, 0.978829066366762, 0.979123422777348,
                                 0.979414818921214, 0.979703271949994, 0.979988799016105, 0.980271417272113, 0.980551143870099,
                                 0.980827995961022, 0.981101990694085, 0.981373145216106, 0.981641476670883, 0.981907002198567,
                                 0.982169738935031, 0.982429704011242, 0.982686914552633, 0.982941387678479, 0.983193140501271,
                                 0.983442190126094, 0.983688553649998, 0.983932248161386, 0.984173290739385, 0.984411698453232,
                                 0.984647488361653, 0.984880677512247, 0.985111282940870, 0.985339321671021, 0.985564810713226,
                                 0.985787767064429, 0.986008207707378, 0.986226149610017, 0.986441609724876, 0.986654604988464,
                                 0.986865152320663, 0.987073268624123, 0.987278970783656, 0.987482275665637, 0.987683200117401,
                                 0.987881760966643, 0.988077975020819, 0.988271859066550, 0.988463429869024, 0.988652704171403,
                                 0.988839698694230, 0.989024430134834, 0.989206915166743, 0.989387170439091, 0.989565212576034,
                                 0.989741058176161, 0.989914723811909, 0.990086226028979, 0.990255581345755, 0.990422806252723,
                                 0.990587917211889, 0.990750930656205, 0.990911862988989, 0.991070730583351, 0.991227549781622,
                                 0.991382336894777, 0.991535108201868, 0.991685879949455, 0.991834668351035, 0.991981489586482,
                                 0.992126359801477, 0.992269295106946, 0.992410311578503, 0.992549425255884, 0.992686652142396,
                                 0.992822008204353, 0.992955509370527, 0.993087171531592, 0.993217010539574, 0.993345042207298,
                                 0.993471282307846, 0.993595746574002, 0.993718450697715, 0.993839410329551, 0.993958641078154,
                                 0.994076158509706, 0.994191978147388, 0.994306115470846, 0.994418585915654, 0.994529404872783,
                                 0.994638587688071, 0.994746149661694, 0.994852106047637, 0.994956472053171, 0.995059262838328,
                                 0.995160493515383, 0.995260179148328, 0.995358334752363, 0.995454975293372, 0.995550115687415,
                                 0.995643770800213, 0.995735955446641, 0.995826684390218, 0.995915972342601, 0.996003833963084,
                                 0.996090283858092, 0.996175336580687, 0.996259006630063, 0.996341308451058, 0.996422256433657,
                                 0.996501864912498, 0.996580148166390, 0.996657120417819, 0.996732795832466, 0.996807188518726,
                                 0.996880312527226, 0.996952181850344, 0.997022810421740, 0.997092212115875, 0.997160400747545,
                                 0.997227390071409, 0.997293193781522, 0.997357825510874, 0.997421298830924, 0.997483627251142,
                                 0.997544824218553, 0.997604903117279, 0.997663877268090, 0.997721759927952, 0.997778564289581,
                                 0.997834303480995, 0.997888990565078, 0.997942638539131, 0.997995260334443, 0.998046868815853,
                                 0.998097476781316, 0.998147096961478, 0.998195742019246, 0.998243424549364, 0.998290157077994,
                                 0.998335952062294, 0.998380821890006, 0.998424778879041, 0.998467835277068, 0.998510003261108,
                                 0.998551294937128, 0.998591722339642, 0.998631297431310, 0.998670032102542, 0.998707938171109,
                                 0.998745027381747, 0.998781311405776, 0.998816801840714, 0.998851510209897, 0.998885447962099,
                                 0.998918626471161, 0.998951057035621, 0.998982750878341, 0.999013719146146, 0.999043972909463,
                                 0.999073523161962, 0.999102380820201, 0.999130556723274, 0.999158061632466, 0.999184906230906,
                                 0.999211101123227, 0.999236656835229, 0.999261583813545, 0.999285892425309, 0.999309592957833,
                                 0.999332695618281, 0.999355210533352, 0.999377147748962, 0.999398517229937, 0.999419328859698,
                                 0.999439592439967, 0.999459317690457, 0.999478514248583, 0.999497191669167, 0.999515359424152,
                                 0.999533026902316, 0.999550203408996, 0.999566898165809, 0.999583120310382, 0.999598878896088,
                                 0.999614182891779, 0.999629041181534, 0.999643462564398, 0.999657455754141, 0.999671029379010,
                                 0.999684191981487, 0.999696952018059, 0.999709317858985, 0.999721297788072, 0.999732900002453,
                                 0.999744132612374, 0.999755003640982, 0.999765521024119, 0.999775692610125, 0.999785526159640,
                                 0.999795029345419, 0.999804209752141, 0.999813074876237, 0.999821632125715, 0.999829888819990,
                                 0.999837852189727, 0.999845529376681, 0.999852927433551, 0.999860053323833, 0.999866913921684,
                                 0.999873516011790, 0.999879866289240, 0.999885971359408, 0.999891837737842, 0.999897471850155,
                                 0.999902880031929, 0.999908068528620, 0.999913043495475, 0.999917810997454, 0.999922377009157,
                                 0.999926747414763, 0.999930928007971, 0.999934924491952, 0.999938742479314, 0.999942387492058,
                                 0.999945864961564, 0.999949180228568, 0.999952338543156, 0.999955345064765, 0.999958204862189,
                                 0.999960922913603, 0.999963504106583, 0.999965953238146, 0.999968275014798, 0.999970474052585,
                                 0.999972554877163, 0.999974521923870, 0.999976379537816, 0.999978131973977, 0.999979783397304,
                                 0.999981337882844, 0.999982799415866, 0.999984171892008, 0.999985459117431, 0.999986664808984,
                                 0.999987792594384, 0.999988846012411, 0.999989828513115, 0.999990743458034, 0.999991594120432,
                                 0.999992383685547, 0.999993115250856, 0.999993791826359, 0.999994416334874, 0.999994991612352,
                                 0.999995520408209, 0.999996005385678, 0.999996449122175, 0.999996854109692, 0.999997222755203,
                                 0.999997557381095, 0.999997860225620, 0.999998133443374, 0.999998379105795, 0.999998599201686,
                                 0.999998795637770, 0.999998970239269, 0.999999124750510, 0.999999260835571, 0.999999380078947,
                                 0.999999483986260, 0.999999573985005, 0.999999651425327, 0.999999717580853, 0.999999773649554,
                                 0.999999820754667, 0.999999859945661, 0.999999892199262, 0.999999918420540, 0.999999939444061,
                                 0.999999956035110, 0.999999968890998, 0.999999978642463, 0.999999985855159, 0.999999991031280,
                                 0.999999994611299, 0.999999996975875, 0.999999998447931, 0.999999999294973, 0.999999999731666,
                                 0.999999999922788, 0.999999999986664, 0.999999999999338, 1};
    return (tOutput);
}

TEST(PlatoTest, Uniform)
{
    const double tLowerBound = 2;
    const double tUpperBound = 7;
    Plato::UniformDistribution<double> tDistribution(tLowerBound, tUpperBound);

    // ********** TEST STATISTICS FOR UNIFORM DISTRIBUTION **********
    const double tTolerance = 1e-5;
    EXPECT_NEAR(tLowerBound, tDistribution.lower(), tTolerance);
    EXPECT_NEAR(tUpperBound, tDistribution.upper(), tTolerance);
    double tGoldValue = 4.5;
    EXPECT_NEAR(tGoldValue, tDistribution.mean(), tTolerance);
    tGoldValue = (1. / 12.) * (tUpperBound - tLowerBound) * (tUpperBound - tLowerBound);
    EXPECT_NEAR(tGoldValue, tDistribution.variance(), tTolerance);
    tGoldValue = std::log(tUpperBound - tLowerBound);
    EXPECT_NEAR(tGoldValue, tDistribution.entropy(), tTolerance);
    // ********** TEST PDF **********
    std::vector<double> tSamples;
    tSamples.push_back(1);
    tSamples.push_back(2);
    tSamples.push_back(3);
    tSamples.push_back(4);
    tSamples.push_back(5);
    tSamples.push_back(6);
    tSamples.push_back(7);
    tSamples.push_back(8);
    std::vector<double> tGoldPDF;
    tGoldPDF.push_back(0);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0);
    for(size_t tIndex = 0; tIndex < tGoldPDF.size(); tIndex++)
    {
        EXPECT_NEAR(tGoldPDF[tIndex], tDistribution.pdf(tSamples[tIndex]), tTolerance);
    }
    // ********** TEST CDF **********
    std::vector<double> tGoldCDF;
    tGoldCDF.push_back(0);
    tGoldCDF.push_back(0);
    tGoldCDF.push_back(.2);
    tGoldCDF.push_back(.4);
    tGoldCDF.push_back(.6);
    tGoldCDF.push_back(.8);
    tGoldCDF.push_back(1);
    tGoldCDF.push_back(1);
    for(size_t tIndex = 0; tIndex < tGoldCDF.size(); tIndex++)
    {
        EXPECT_NEAR(tGoldCDF[tIndex], tDistribution.cdf(tSamples[tIndex]), tTolerance);
    }
    // ********** TEST MOMENTS **********
    size_t tNumMoments = 8;
    for(size_t tOrder = 0; tOrder <= tNumMoments; tOrder++)
    {
        double tExponent = tOrder + 1u;
        double tGold = (std::pow(tUpperBound, tExponent) - std::pow(tLowerBound, tExponent))
                / (tExponent * (tUpperBound - tLowerBound));
        EXPECT_NEAR(tGold, tDistribution.moment(tOrder), tTolerance);
    }
}

TEST(PlatoTest, Normal)
{
    const double tMean = 0;
    const double tSigma = 1;

    double tEndRange = 1e3;
    double tBeginRange = -1e3;
    double tIncrement = 0.1;
    double tRange = ((tEndRange - tBeginRange) / tIncrement) + 1;
    std::vector<double> tNumbers(tRange);

    std::vector<double> tPDF(tRange);
    std::vector<double> tCDF(tRange);
    for(size_t tIndex = 0; tIndex < tRange; tIndex++)
    {
        tNumbers[tIndex] = tBeginRange + (tIncrement * tIndex);
        tPDF[tIndex] = Plato::normal_pdf<double>(tNumbers[tIndex], tMean, tSigma);
        tCDF[tIndex] = Plato::normal_cdf<double>(tNumbers[tIndex], tMean, tSigma);
    }

    const double tBaseValue = 0;
    const double tTolerance = 1e-3;
    double tValue = std::accumulate(tPDF.begin(), tPDF.end(), tBaseValue) / tRange;
    EXPECT_NEAR(tValue, tMean, tTolerance);
}

TEST(PlatoTest, SromCDF)
{
    double tSample = 0.276806509167094;
    Plato::StandardVector<double> tSamples(4, 0.);
    tSamples[0] = 0.276806509167094;
    tSamples[1] = 0.431107226622461;
    tSamples[2] = 0.004622102620248;
    tSamples[3] = 0.224162021074166;
    Plato::StandardVector<double> tSampleProbabilities(4, 0.);
    tSampleProbabilities[0] = 0.25;
    tSampleProbabilities[1] = 0.25;
    tSampleProbabilities[2] = 0.25;
    tSampleProbabilities[3] = 0.25;
    double tSigma = 1e-3;

    double tOutput = Plato::compute_srom_cdf<double>(tSample, tSigma, tSamples, tSampleProbabilities);

    double tGold = 0.625;
    double tTolerance = 1e-4;
    EXPECT_NEAR(tGold, tOutput, tTolerance);
}

TEST(PlatoTest, SromMoments)
{
    Plato::StandardVector<double> tSamples(4, 0.);
    tSamples[0] = 0.276806509167094;
    tSamples[1] = 0.431107226622461;
    tSamples[2] = 0.004622102620248;
    tSamples[3] = 0.224162021074166;
    Plato::StandardVector<double> tSampleProbabilities(4, 0.);
    tSampleProbabilities[0] = 0.25;
    tSampleProbabilities[1] = 0.25;
    tSampleProbabilities[2] = 0.25;
    tSampleProbabilities[3] = 0.25;

    Plato::StandardVector<double> tMoments(4, 0.);
    for(size_t tIndex = 0; tIndex < tMoments.size(); tIndex++)
    {
        double tOrder = tIndex + static_cast<size_t>(1);
        tMoments[tIndex] = Plato::compute_srom_moment<double>(tOrder, tSamples, tSampleProbabilities);
    }

    Plato::StandardVector<double> tGold(4, 0.);
    tGold[0] = 0.234174464870992;
    tGold[1] = 0.078186314972017;
    tGold[2] = 0.028149028892565;
    tGold[3] = 0.010734332952929;
    PlatoTest::checkVectorData(tMoments, tGold);
}

TEST(PlatoTest, factorial)
{
    size_t tGold = 1;
    size_t tValue = Plato::factorial<size_t>(0);
    EXPECT_EQ(tGold, tValue);

    tGold = 1;
    tValue = Plato::factorial<size_t>(1);
    EXPECT_EQ(tGold, tValue);

    tGold = 362880;
    tValue = Plato::factorial<size_t>(9);
    EXPECT_EQ(tGold, tValue);
}

TEST(PlatoTest, Beta)
{
    double tAlpha = 1;
    double tBeta = 3;
    double tValue = Plato::beta<double>(tAlpha, tBeta);

    double tTolerance = 1e-6;
    double tGold = 1. / 3.;
    EXPECT_NEAR(tGold, tValue, tTolerance);
}

TEST(PlatoTest, PochhammerSymbol)
{
    // TEST ONE: NON-FINITE NUMBER CASE
    double tOutput = Plato::pochhammer_symbol<double>(-2, 0);
    const double tTolerance = 1e-5;
    EXPECT_NEAR(0, tOutput, tTolerance);

    // TEST TWO: FINITE NUMBER CASE
    tOutput = Plato::pochhammer_symbol<double>(2.166666666666666, 4.333333333333333);
    double tGold = 265.98433449717857;
    EXPECT_NEAR(tGold, tOutput, tTolerance);
}

TEST(PlatoTest, BetaMoment)
{
    size_t tOrder = 3;
    double tAlpha = 2.166666666666666;
    double tBeta = 4.333333333333333;
    double tValue = Plato::beta_moment<double>(tOrder, tAlpha, tBeta);

    double tTolerance = 1e-6;
    double tGold = 0.068990559186638;
    EXPECT_NEAR(tGold, tValue, tTolerance);
}

TEST(PlatoTest, ComputeShapeParameters)
{
    const double tMean = 90;
    const double tMaxValue = 135;
    const double tMinValue = 67.5;
    const double tVariance = 135;
    double tAlphaShapeParameter = 0;
    double tBetaShapeParameter = 0;
    Plato::shape_parameters<double>(tMinValue, tMaxValue, tMean, tVariance, tAlphaShapeParameter, tBetaShapeParameter);

    const double tTolerance = 1e-6;
    const double tGoldAlpha = 2.166666666666666;
    const double tGoldBeta = 4.333333333333333;
    EXPECT_NEAR(tGoldBeta, tBetaShapeParameter, tTolerance);
    EXPECT_NEAR(tGoldAlpha, tAlphaShapeParameter, tTolerance);
}

TEST(PlatoTest, IncompleteBeta)
{
    double tSample = 1.;
    const double tAlpha = 2.166666666666666;
    const double tBeta = 4.333333333333333;

    double tOutput = Plato::incomplete_beta<double>(tSample, tAlpha, tBeta);

    const double tTolerance = 1e-5;
    const double tGold = Plato::beta<double>(tAlpha, tBeta);
    EXPECT_NEAR(tOutput, tGold, tTolerance);
}

TEST(PlatoTest, BetaPDF)
{
    const size_t tRange = 4;
    std::vector<double> tPDF(tRange);
    std::vector<double> tShapeParam(tRange);
    tShapeParam[0] = 0.5;
    tShapeParam[1] = 1;
    tShapeParam[2] = 2;
    tShapeParam[3] = 4;
    const double tSample = 0.5;
    for(size_t tIndex = 0; tIndex < tRange; tIndex++)
    {
        tPDF[tIndex] = Plato::beta_pdf<double>(tSample, tShapeParam[tIndex], tShapeParam[tIndex]);
    }

    const double tTolerance = 1e-6;
    std::vector<double> tGoldPDF(tRange, 0.);
    tGoldPDF[0] = 0.636619772367582;
    tGoldPDF[1] = 1.0;
    tGoldPDF[2] = 1.5;
    tGoldPDF[3] = 2.1875;
    for(size_t tIndex = 0; tIndex < tRange; tIndex++)
    {
        EXPECT_NEAR(tPDF[tIndex], tGoldPDF[tIndex], tTolerance);
    }
}

TEST(PlatoTest, BetaCDF)
{
    const double tBeta = 3;
    const double tSample = 0.5;
    const size_t tRange = 11;
    std::vector<double> tCDF(tRange, 0.);
    for(size_t tIndex = 0; tIndex < tRange; tIndex++)
    {
        tCDF[tIndex] = Plato::beta_cdf<double>(tSample, tIndex, tBeta);
    }

    const double tTolerance = 1e-6;
    std::vector<double> tGoldCDF(tRange, 0.);
    tGoldCDF[0] = 1;
    tGoldCDF[1] = 0.875;
    tGoldCDF[2] = 0.6875;
    tGoldCDF[3] = 0.5;
    tGoldCDF[4] = 0.34375;
    tGoldCDF[5] = 0.2265625;
    tGoldCDF[6] = 0.14453125;
    tGoldCDF[7] = 0.08984375;
    tGoldCDF[8] = 0.0546875;
    tGoldCDF[9] = 0.03271484375;
    tGoldCDF[10] = 0.019287109375;
    for(size_t tIndex = 0; tIndex < tRange; tIndex++)
    {
        EXPECT_NEAR(tCDF[tIndex], tGoldCDF[tIndex], tTolerance);
    }
}

TEST(PlatoTest, BetaCDF2)
{
    // BUILD BETA DISTRIBUTION
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    Plato::BetaDistribution<double> tBetaDistribution(tMin, tMax, tMean, tVariance);

    // CONSTRUCT MONTE CARLO SAMPLE VECTOR
    const size_t tNumSamples = 1000;
    const size_t tLength = tNumSamples + static_cast<size_t>(1);
    const double tDelta = 1.0 / tNumSamples;
    std::vector<double> tSamples(tLength);
    for(size_t tIndex = 1; tIndex < tLength; tIndex++)
    {
        size_t tPreviousIndex = tIndex - static_cast<size_t>(1);
        tSamples[tIndex] = tSamples[tPreviousIndex] + tDelta;
    }

    // COMPUTE CDF
    std::vector<double> tCDF(tLength);
    for(size_t tIndex = 0; tIndex < tSamples.size(); tIndex++)
    {
        tCDF[tIndex] = tBetaDistribution.cdf(tSamples[tIndex]);
    }

    // TEST CDF VALUES
    const double tTolerance = 1e-4;
    std::vector<double> tGold = PlatoTest::get_gold_beta_cdf_values();
    EXPECT_EQ(tCDF.size(), tGold.size());
    for(size_t tIndex = 0; tIndex < tSamples.size(); tIndex++)
    {
        EXPECT_NEAR(tCDF[tIndex], tGold[tIndex], tTolerance);
    }
}

TEST(PlatoTest, PlotBetaCDF)
{
    // BUILD BETA DISTRIBUTION
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    Plato::BetaDistribution<double> tBetaDistribution(tMin, tMax, tMean, tVariance);

    // CONSTRUCT MONTE CARLO SAMPLE VECTOR
    const size_t tNumSamples = 1000;
    const size_t tLength = tNumSamples + static_cast<size_t>(1);
    const double tDelta = 1.0 / tNumSamples;
    Plato::StandardVector<double> tSamplesMC(tNumSamples);
    for(size_t tIndex = 1; tIndex < tLength; tIndex++)
    {
        size_t tPreviousIndex = tIndex - static_cast<size_t>(1);
        tSamplesMC[tIndex] = tSamplesMC[tPreviousIndex] + tDelta;
    }

    // COMPUTE MONTE CARLO CDF
    Plato::StandardVector<double> tMonteCarloCDF(tLength);
    EXPECT_EQ(tMonteCarloCDF.size(), tSamplesMC.size());
    for(size_t tIndex = 0; tIndex < tSamplesMC.size(); tIndex++)
    {
        tMonteCarloCDF[tIndex] = tBetaDistribution.cdf(tSamplesMC[tIndex]);
    }

    // POSE SROM PROBLEM WITH KNOWN SOLUTION
    Plato::UncertaintyInputStruct<double> tInput;
    tInput.mDistribution = Plato::DistrubtionName::type_t::beta;
    tInput.mMean = 90.;
    tInput.mUpperBound = 135.;
    tInput.mLowerBound = 67.5;
    tInput.mVariance = 135.;
    tInput.mNumSamples = 20;
    tInput.mMaxNumDistributionMoments = 4;

    // SOLVE
    Plato::AlgorithmParamStruct<double> tParam;
    Plato::SromProblemDiagnosticsStruct<double> tDiagnostics;
    std::vector<Plato::UncertaintyOutputStruct<double>> tOutput;
    Plato::solve_uncertainty(tInput, tParam, tDiagnostics, tOutput);

    Plato::StandardVector<double> tSromCDF(tLength);
    Plato::StandardVector<double> tProbsSROM(tInput.mNumSamples);
    Plato::StandardVector<double> tSamplesSROM(tInput.mNumSamples);
    for(size_t tIndex = 0; tIndex < tInput.mNumSamples; tIndex++)
    {
        tProbsSROM[tIndex] = tOutput[tIndex].mSampleWeight;
        tSamplesSROM[tIndex] = tOutput[tIndex].mSampleValue;
    }

    // CALL CDF PLOT FUNCTION
    PlatoTest::compute_srom_cdf_plot(tSamplesMC, tSamplesSROM, tProbsSROM, tSromCDF);
}

TEST(PlatoTest, BetaDistribution)
{
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    Plato::BetaDistribution<double> tDistribution(tMin, tMax, tMean, tVariance);

    // TEST INPUTS
    const double tTolerance = 1e-5;
    EXPECT_NEAR(tMin, tDistribution.min(), tTolerance);
    EXPECT_NEAR(tMax, tDistribution.max(), tTolerance);
    EXPECT_NEAR(tMean, tDistribution.mean(), tTolerance);
    EXPECT_NEAR(tVariance, tDistribution.variance(), tTolerance);

    // TEST BETA PDF & CDF
    double tSample = 0.276806509167094;
    double tGoldPDF = 2.179085850493935;
    EXPECT_NEAR(tGoldPDF, tDistribution.pdf(tSample), tTolerance);
    double tGoldCDF = 0.417022004702574;
    EXPECT_NEAR(tGoldCDF, tDistribution.cdf(tSample), tTolerance);

    // TEST BETA MOMENTS
    const size_t tNumMoments = 4;
    Plato::StandardVector<double> tGoldMoments(tNumMoments);
    tGoldMoments[0] = 0.333333333333333;
    tGoldMoments[1] = 0.140740740740740;
    tGoldMoments[2] = 0.068990559186638;
    tGoldMoments[3] = 0.037521181312031;
    for(size_t tIndex = 0; tIndex < tNumMoments; tIndex++)
    {
        size_t tOrder = tIndex + 1;
        EXPECT_NEAR(tGoldMoments[tIndex], tDistribution.moment(tOrder), tTolerance);
    }
}

TEST(PlatoTest, SromObjectiveTestOne)
{
    // ********* ALLOCATE BETA DISTRIBUTION *********
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    std::shared_ptr<Plato::BetaDistribution<double>> tDistribution =
            std::make_shared<Plato::BetaDistribution<double>>(tMin, tMax, tMean, tVariance);

    // ********* SET TEST DATA: SAMPLES AND PROBABILITIES *********
    const size_t tNumVectors = 2;
    const size_t tNumSamples = 4;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);
    size_t tVectorIndex = 0;
    tControl(tVectorIndex, 0) = 0.276806509167094;
    tControl(tVectorIndex, 1) = 0.431107226622461;
    tControl(tVectorIndex, 2) = 0.004622102620248;
    tControl(tVectorIndex, 3) = 0.224162021074166;
    tVectorIndex = 1;
    tControl[tVectorIndex].fill(0.25);

    // ********* TEST OBJECTIVE FUNCTION *********
    const size_t tMaxNumMoments = 4;
    Plato::SromObjective<double> tObjective(tDistribution, tMaxNumMoments, tNumSamples);
    tObjective.setCdfMisfitTermWeight(1);
    tObjective.setMomentMisfitTermWeight(1);
    double tValue = tObjective.value(tControl);
    double tTolerance = 1e-5;
    double tGold = 0.617109315688096;
    EXPECT_NEAR(tGold, tValue, tTolerance);

    // ********* TEST OBJECTIVE GRADIENT *********
    Plato::StandardMultiVector<double> tGradient(tNumVectors, tNumSamples);
    tObjective.gradient(tControl, tGradient);
    Plato::StandardMultiVector<double> tGradientGold(tNumVectors, tNumSamples);
    tVectorIndex = 0;
    tGradientGold(tVectorIndex, 0) = -2.010045017107233;
    tGradientGold(tVectorIndex, 1) = -3.878346258927178;
    tGradientGold(tVectorIndex, 2) = -0.237208262654126;
    tGradientGold(tVectorIndex, 3) = -1.271234346951175;
    tVectorIndex = 1;
    tGradientGold(tVectorIndex, 0) = -0.524038145360132;
    tGradientGold(tVectorIndex, 1) = -2.239056684273221;
    tGradientGold(tVectorIndex, 2) = 0.493570515676146;
    tGradientGold(tVectorIndex, 3) = -0.104442116117926;
    PlatoTest::checkMultiVectorData(tGradient, tGradientGold);
}

TEST(PlatoTest, SromObjectiveTestTwo)
{
    // ********* ALLOCATE BETA DISTRIBUTION *********
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    std::shared_ptr<Plato::BetaDistribution<double>> tDistribution =
            std::make_shared<Plato::BetaDistribution<double>>(tMin, tMax, tMean, tVariance);

    // ********* SET TEST DATA: SAMPLES AND PROBABILITIES *********
    const size_t tNumVectors = 3;
    const size_t tNumSamples = 4;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);
    size_t tVectorIndex = 0;
    tControl(tVectorIndex, 0) = 0.276806509167094;
    tControl(tVectorIndex, 1) = 0.004622102620248;
    tControl(tVectorIndex, 2) = 0.376806509167094;
    tControl(tVectorIndex, 3) = 0.104622102620248;
    tVectorIndex = 1;
    tControl(tVectorIndex, 0) = 0.431107226622461;
    tControl(tVectorIndex, 1) = 0.224162021074166;
    tControl(tVectorIndex, 2) = 0.531107226622461;
    tControl(tVectorIndex, 3) = 0.324162021074166;
    tVectorIndex = 2;
    tControl[tVectorIndex].fill(0.25);

    // ********* TEST OBJECTIVE FUNCTION *********
    const size_t tRandomVecDim = 2;
    const size_t tMaxNumMoments = 4;
    Plato::SromObjective<double> tObjective(tDistribution, tMaxNumMoments, tNumSamples, tRandomVecDim);
    tObjective.setCdfMisfitTermWeight(1);
    tObjective.setMomentMisfitTermWeight(1);
    double tValue = tObjective.value(tControl);
    double tTolerance = 1e-5;
    double tGold = 1.032230626961365;
    EXPECT_NEAR(tGold, tValue, tTolerance);

    // ********* TEST OBJECTIVE GRADIENT *********
    Plato::StandardMultiVector<double> tGradient(tNumVectors, tNumSamples);
    tObjective.gradient(tControl, tGradient);
    Plato::StandardMultiVector<double> tGradientGold(tNumVectors, tNumSamples);
    tVectorIndex = 0;
    tGradientGold(tVectorIndex, 0) = -2.42724408126656;
    tGradientGold(tVectorIndex, 1) = -0.337450847795798;
    tGradientGold(tVectorIndex, 2) = -3.887791716578634;
    tGradientGold(tVectorIndex, 3) = -1.076413326527892;
    tVectorIndex = 1;
    tGradientGold(tVectorIndex, 0) = 0.096246202011561;
    tGradientGold(tVectorIndex, 1) = 0.520617569090164;
    tGradientGold(tVectorIndex, 2) = -0.321363712239195;
    tGradientGold(tVectorIndex, 3) = 0.384504837554259;
    tVectorIndex = 2;
    tGradientGold(tVectorIndex, 0) = -0.53206506489113;
    tGradientGold(tVectorIndex, 1) = 0.619653114279367;
    tGradientGold(tVectorIndex, 2) = -1.84853491196106;
    tGradientGold(tVectorIndex, 3) = 0.426963908092988;
    PlatoTest::checkMultiVectorData(tGradient, tGradientGold);
}

TEST(PlatoTest, SromConstraint)
{
    // ********* SET TEST DATA: SAMPLES AND PROBABILITIES *********
    const size_t tNumVectors = 2;
    const size_t tNumSamples = 4;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);
    size_t tVectorIndex = 0;
    tControl(tVectorIndex, 0) = 0.183183326166505;
    tControl(tVectorIndex, 1) = 0.341948604575779;
    tControl(tVectorIndex, 2) = 0.410656896223290;
    tControl(tVectorIndex, 3) = 0.064209040541960;
    tVectorIndex = 1;
    tControl(tVectorIndex, 0) = 0.434251989288042;
    tControl(tVectorIndex, 1) = 0.351721349341024;
    tControl(tVectorIndex, 2) = 0.001250000000000;
    tControl(tVectorIndex, 3) = 0.212776663693648;

    // ********* TEST CONSTRAINT EVALUATION *********
    std::shared_ptr<Plato::StandardVectorReductionOperations<double>> tReductions =
            std::make_shared<Plato::StandardVectorReductionOperations<double>>();
    Plato::SromConstraint<double> tConstraint(tReductions);
    double tValue = tConstraint.value(tControl);

    double tGoldValue = 0;
    double tTolerance = 1e-6;
    EXPECT_NEAR(tGoldValue, tValue, tTolerance);

    // ********* TEST CONSTRAINT GRADIENT *********
    Plato::StandardMultiVector<double> tGradient(tNumVectors, tNumSamples);
    tConstraint.gradient(tControl, tGradient);
    Plato::StandardMultiVector<double> tGradientGold(tNumVectors, tNumSamples);
    tVectorIndex = 0;
    tGradientGold(tVectorIndex, 0) = 0;
    tGradientGold(tVectorIndex, 1) = 0;
    tGradientGold(tVectorIndex, 2) = 0;
    tGradientGold(tVectorIndex, 3) = 0;
    tVectorIndex = 1;
    tGradientGold(tVectorIndex, 0) = 1;
    tGradientGold(tVectorIndex, 1) = 1;
    tGradientGold(tVectorIndex, 2) = 1;
    tGradientGold(tVectorIndex, 3) = 1;
    PlatoTest::checkMultiVectorData(tGradient, tGradientGold);
}

TEST(PlatoTest, NormalDistribution)
{
    double tMean = 1;
    double tStandardDeviation = 0.5;
    Plato::NormalDistribution<double> tDistribution(tMean, tStandardDeviation);

    double tGoldValue = 1;
    double tTolerance = 1e-6;
    EXPECT_NEAR(tGoldValue, tDistribution.mean(), tTolerance);
    tGoldValue = 0.5;
    EXPECT_NEAR(tGoldValue, tDistribution.sigma(), tTolerance);

    // ********* TEST GAUSSIAN PDF AND CDF *********
    double tSample = 0.2;
    tGoldValue = 0.221841669358911;
    EXPECT_NEAR(tGoldValue, tDistribution.pdf(tSample), tTolerance);
    tGoldValue = 0.054799291699558;
    EXPECT_NEAR(tGoldValue, tDistribution.cdf(tSample), tTolerance);

    // ********* TEST GAUSSIAN MOMENTS *********
    size_t tMaxNumMoments = 8;
    std::vector<double> tGoldMoments(tMaxNumMoments + 1u);
    tGoldMoments[0] = 1;
    tGoldMoments[1] = tMean;
    tGoldMoments[2] = std::pow(tMean, 2.) + std::pow(tStandardDeviation, 2.);
    tGoldMoments[3] = std::pow(tMean, 3.) + 3 * tMean * std::pow(tStandardDeviation, 2.);
    tGoldMoments[4] = std::pow(tMean, 4.) + 6 * std::pow(tMean, 2.) * std::pow(tStandardDeviation, 2.)
                      + 3 * std::pow(tStandardDeviation, 4.);
    tGoldMoments[5] = std::pow(tMean, 5.) + 10 * std::pow(tMean, 3.) * std::pow(tStandardDeviation, 2.)
                      + 15 * tMean * std::pow(tStandardDeviation, 4.);
    tGoldMoments[6] = std::pow(tMean, 6.) + 15 * std::pow(tMean, 4.) * std::pow(tStandardDeviation, 2.)
                      + 45 * std::pow(tMean, 2.) * std::pow(tStandardDeviation, 4.) + 15 * std::pow(tStandardDeviation, 6.);
    tGoldMoments[7] = std::pow(tMean, 7.) + 21 * std::pow(tMean, 5.) * std::pow(tStandardDeviation, 2.)
                      + 105 * std::pow(tMean, 3.) * std::pow(tStandardDeviation, 4.)
                      + 105 * tMean * std::pow(tStandardDeviation, 6.);
    tGoldMoments[8] = std::pow(tMean, 8.) + 28 * std::pow(tMean, 6.) * std::pow(tStandardDeviation, 2.)
                      + 210 * std::pow(tMean, 4.) * std::pow(tStandardDeviation, 4.)
                      + 420 * std::pow(tMean, 2.) * std::pow(tStandardDeviation, 6.)
                      + 105 * tMean * std::pow(tStandardDeviation, 8.);
    for(size_t tOrder = 0; tOrder <= tMaxNumMoments; tOrder++)
    {
        double tValue = tDistribution.moment(tOrder);
        EXPECT_NEAR(tGoldMoments[tOrder], tValue, tTolerance);
    }
}

TEST(PlatoTest, CheckSromObjectiveGradient)
{
    // ********* ALLOCATE BETA DISTRIBUTION *********
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    std::shared_ptr<Plato::BetaDistribution<double>> tDistribution =
            std::make_shared<Plato::BetaDistribution<double>>(tMin, tMax, tMean, tVariance);

    // ********* CHECK OBJECTIVE GRADIENT *********
    std::ostringstream tOutputMsg;
    const size_t tNumSamples = 4;
    const size_t tMaxNumMoments = 4;
    Plato::Diagnostics<double> tDiagnostics;
    Plato::SromObjective<double> tObjective(tDistribution, tMaxNumMoments, tNumSamples);

    const size_t tNumVectors = 2;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);
    tDiagnostics.checkCriterionGradient(tObjective, tControl, tOutputMsg);
    EXPECT_TRUE(tDiagnostics.didGradientTestPassed());

    int tMyRank = -1;
    MPI_Comm_rank(MPI_COMM_WORLD, &tMyRank);
    if(tMyRank == static_cast<int>(0))
    {
        std::cout << tOutputMsg.str().c_str();
    }
}

TEST(PlatoTest, CheckSromConstraintGradient)
{
    // ********* CHECK CONSTRAINT GRADIENT *********
    std::shared_ptr<Plato::StandardVectorReductionOperations<double>> tReductions =
            std::make_shared<Plato::StandardVectorReductionOperations<double>>();
    Plato::SromConstraint<double> tConstraint(tReductions);

    const size_t tNumVectors = 2;
    const size_t tNumSamples = 4;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);

    std::ostringstream tOutputMsg;
    Plato::Diagnostics<double> tDiagnostics;
    tDiagnostics.checkCriterionGradient(tConstraint, tControl, tOutputMsg);
    EXPECT_TRUE(tDiagnostics.didGradientTestPassed());

    int tMyRank = -1;
    MPI_Comm_rank(MPI_COMM_WORLD, &tMyRank);
    if(tMyRank == static_cast<int>(0))
    {
        std::cout << tOutputMsg.str().c_str();
    }
}

TEST(PlatoTest, SromOptimizationProblem)
{
    // ********* ALLOCATE DATA FACTORY *********
    std::shared_ptr<Plato::DataFactory<double>> tDataFactory =
            std::make_shared<Plato::DataFactory<double>>();
    const size_t tNumDuals = 1;
    const size_t tNumSamples = 4;
    const size_t tNumControlVectors = 2;
    tDataFactory->allocateDual(tNumDuals);
    tDataFactory->allocateControl(tNumSamples, tNumControlVectors);

    // ********* ALLOCATE BETA DISTRIBUTION *********
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    std::shared_ptr<Plato::BetaDistribution<double>> tDistribution =
            std::make_shared<Plato::BetaDistribution<double>>(tMin, tMax, tMean, tVariance);

    // ********* ALLOCATE OBJECTIVE AND CONSTRAINT CRITERIA *********
    const size_t tMaxNumMoments = 4;
    std::shared_ptr<Plato::SromObjective<double>> tSromObjective =
            std::make_shared<Plato::SromObjective<double>>(tDistribution, tMaxNumMoments, tNumSamples);
    EXPECT_EQ(tNumSamples, tSromObjective->getNumSamples());
    EXPECT_EQ(tMaxNumMoments, tSromObjective->getMaxNumMoments());

    std::shared_ptr<Plato::ReductionOperations<double>> tReductions = tDataFactory->getControlReductionOperations().create();
    std::shared_ptr<Plato::SromConstraint<double>> tSromConstraint = std::make_shared<Plato::SromConstraint<double>>(tReductions);
    std::shared_ptr<Plato::CriterionList<double>> tConstraintList = std::make_shared<Plato::CriterionList<double>>();
    tConstraintList->add(tSromConstraint);

    // ********* AUGMENTED LAGRANGIAN STAGE MANAGER *********
    std::shared_ptr<Plato::AugmentedLagrangianStageMng<double>> tStageMng =
            std::make_shared<Plato::AugmentedLagrangianStageMng<double>>(tDataFactory, tSromObjective, tConstraintList);

    // ********* ALLOCATE TRUST REGION ALGORITHM DATA MANAGER *********
    std::shared_ptr<Plato::TrustRegionAlgorithmDataMng<double>> tDataMng =
            std::make_shared<Plato::TrustRegionAlgorithmDataMng<double>>(tDataFactory);

    // ********* SET INTIAL GUESS FOR VECTOR OF SAMPLES *********
    Plato::StandardVector<double> tVector(tNumSamples);
    for(size_t tIndex = 0; tIndex < tNumSamples; tIndex++)
    {
        double tValue = (1. / static_cast<double>(tNumSamples + 1u));
        tVector[tIndex] = static_cast<double>(tIndex + 1u) * tValue;
    }
    size_t tVectorIndex = 0;
    tDataMng->setInitialGuess(tVectorIndex, tVector);
    // ********* SET INTIAL GUESS FOR VECTOR OF PROBABILITIES *********
    double tScalarValue = 1. / static_cast<double>(4);
    tVector.fill(tScalarValue);
    tVectorIndex = 1;
    tDataMng->setInitialGuess(tVectorIndex, tVector);
    // ********* SET UPPER AND LOWER BOUNDS *********
    tScalarValue = 0;
    tDataMng->setControlLowerBounds(tScalarValue);
    tScalarValue = 1;
    tDataMng->setControlUpperBounds(tScalarValue);

    // ********* ALLOCATE KELLEY-SACHS ALGORITHM *********
    Plato::KelleySachsAugmentedLagrangian<double> tAlgorithm(tDataFactory, tDataMng, tStageMng);
    tAlgorithm.solve();

    size_t tGoldIterations = 38;
    EXPECT_EQ(tGoldIterations, tAlgorithm.getNumIterationsDone());

    // ********* TEST RESULTS *********
    size_t tNumVectors = 1;
    Plato::StandardMultiVector<double> tConstraintValues(tNumVectors, tNumDuals);
    tStageMng->getCurrentConstraintValues(tConstraintValues);
    double tTolerance = 1e-5;
    double tGoldValue = -0.00014696838926697708;
    EXPECT_NEAR(tGoldValue, tConstraintValues(0,0), tTolerance);

    Plato::StandardMultiVector<double> tGoldControl(tNumControlVectors, tNumSamples);
    // GOLD SAMPLES
    tGoldControl(0,0) = 0.16377870487690938;
    tGoldControl(0,1) = 0.409813078171542;
    tGoldControl(0,2) = 0.56692565516265081;
    tGoldControl(0,3) = 0.28805773602398665;
    // GOLD PROBABILITIES
    tGoldControl(1,0) = 0.24979311097918996;
    tGoldControl(1,1) = 0.24999286050154013;
    tGoldControl(1,2) = 0.25018122221660277;
    tGoldControl(1,3) = 0.24988583791340019;
    PlatoTest::checkMultiVectorData(tDataMng->getCurrentControl(), tGoldControl);

    // TEST ACCESSOR FUNCTIONS
    EXPECT_NEAR(0.011192979601439203, tSromObjective->getCumulativeDistributionFunctionError(), tTolerance);
    EXPECT_EQ(static_cast<size_t>(1), tSromObjective->getMomentError().getNumVectors());
    const size_t tRANDOM_VEC_DIM = 0;
    EXPECT_EQ(tMaxNumMoments, tSromObjective->getMomentError(tRANDOM_VEC_DIM).size());
    EXPECT_NEAR(0.0051166144050895333, tSromObjective->getMomentError(tRANDOM_VEC_DIM)[0], tTolerance);
    EXPECT_NEAR(0.0041708441435645144, tSromObjective->getMomentError(tRANDOM_VEC_DIM)[1], tTolerance);
    EXPECT_NEAR(0.0001597576589617835, tSromObjective->getMomentError(tRANDOM_VEC_DIM)[2], tTolerance);
    EXPECT_NEAR(0.0052769725525790403, tSromObjective->getMomentError(tRANDOM_VEC_DIM)[3], tTolerance);
    EXPECT_EQ(tMaxNumMoments, tSromObjective->getTrueMoments().size());
    EXPECT_NEAR(0.33333333333333337, tSromObjective->getTrueMoments()[0], tTolerance);
    EXPECT_NEAR(0.1407407407407405, tSromObjective->getTrueMoments()[1], tTolerance);
    EXPECT_NEAR(0.06899055918663749, tSromObjective->getTrueMoments()[2], tTolerance);
    EXPECT_NEAR(0.037521181312030978, tSromObjective->getTrueMoments()[3], tTolerance);
    EXPECT_EQ(tMaxNumMoments, tSromObjective->getSromMoments().size());
    EXPECT_NEAR(0.35717683793472566, tSromObjective->getSromMoments()[0], tTolerance);
    EXPECT_NEAR(0.14983006952307662, tSromObjective->getSromMoments()[1], tTolerance);
    EXPECT_NEAR(0.069862567266374576, tSromObjective->getSromMoments()[2], tTolerance);
    EXPECT_NEAR(0.034795538633737751, tSromObjective->getSromMoments()[3], tTolerance);
    EXPECT_EQ(static_cast<size_t>(1), tSromObjective->getTrueCDF().getNumVectors());
    EXPECT_EQ(tNumSamples, tSromObjective->getTrueCDF(tRANDOM_VEC_DIM).size());
    EXPECT_NEAR(0.17821214529480175, tSromObjective->getTrueCDF(tRANDOM_VEC_DIM)[0], tTolerance);
    EXPECT_NEAR(0.68420782522934132, tSromObjective->getTrueCDF(tRANDOM_VEC_DIM)[1], tTolerance);
    EXPECT_NEAR(0.89353339757926531, tSromObjective->getTrueCDF(tRANDOM_VEC_DIM)[2], tTolerance);
    EXPECT_NEAR(0.44147406832303915, tSromObjective->getTrueCDF(tRANDOM_VEC_DIM)[3], tTolerance);
    EXPECT_EQ(static_cast<size_t>(1), tSromObjective->getSromCDF().getNumVectors());
    EXPECT_EQ(tNumSamples, tSromObjective->getSromCDF(tRANDOM_VEC_DIM).size());
    EXPECT_NEAR(0.12489655548959624, tSromObjective->getSromCDF(tRANDOM_VEC_DIM)[0], tTolerance);
    EXPECT_NEAR(0.62467537914336646, tSromObjective->getSromCDF(tRANDOM_VEC_DIM)[1], tTolerance);
    EXPECT_NEAR(0.87476242050244046, tSromObjective->getSromCDF(tRANDOM_VEC_DIM)[2], tTolerance);
    EXPECT_NEAR(0.37473602993589383, tSromObjective->getSromCDF(tRANDOM_VEC_DIM)[3], tTolerance);
}

TEST(PlatoTest, solveUncertaintyProblem_checkSize)
{
    // POSE INPUT DISTRIBUTION
    Plato::UncertaintyInputStruct<double, size_t> tInput;
    tInput.mDistribution = Plato::DistrubtionName::type_t::beta;
    tInput.mMean = 1.0;
    tInput.mLowerBound = 0.0;
    tInput.mUpperBound = 2.0;
    tInput.mVariance = 0.5;
    tInput.mNumSamples = 5;

    // SOLVE
    Plato::AlgorithmParamStruct<double, size_t> tParam;
    Plato::SromProblemDiagnosticsStruct<double> tDiagnostics;
    std::vector<Plato::UncertaintyOutputStruct<double>> tOutput;
    Plato::solve_uncertainty(tInput, tParam, tDiagnostics, tOutput);

    // CHECK
    EXPECT_EQ(tOutput.size(), tInput.mNumSamples);

    // CHECK DIAGNOSTICS OUTPUT
    EXPECT_EQ(tInput.mNumSamples, tDiagnostics.mSromCDF.size());
    EXPECT_EQ(tInput.mNumSamples, tDiagnostics.mTrueCDF.size());
    EXPECT_EQ(tInput.mMaxNumDistributionMoments, tDiagnostics.mSromMoments.size());
    EXPECT_EQ(tInput.mMaxNumDistributionMoments, tDiagnostics.mTrueMoments.size());
    EXPECT_EQ(tInput.mMaxNumDistributionMoments, tDiagnostics.mMomentErrors.size());

    const double tTolerance = 1e-6;
    EXPECT_NEAR(0.031222598068113901, tDiagnostics.mCumulativeDistributionFunctionError, tTolerance);
    EXPECT_NEAR(0.0080309885157028253, tDiagnostics.mMomentErrors[0], tTolerance);
    EXPECT_NEAR(0.00059230417679088476, tDiagnostics.mMomentErrors[1], tTolerance);
    EXPECT_NEAR(0.0003054453504334667, tDiagnostics.mMomentErrors[2], tTolerance);
    EXPECT_NEAR(0.0016131419470630369, tDiagnostics.mMomentErrors[3], tTolerance);
    EXPECT_NEAR(0.54480789136888397, tDiagnostics.mSromMoments[0], tTolerance);
    EXPECT_NEAR(0.38412648754238005, tDiagnostics.mSromMoments[1], tTolerance);
    EXPECT_NEAR(0.30703843909644246, tDiagnostics.mSromMoments[2], tTolerance);
    EXPECT_NEAR(0.26245517309625521, tDiagnostics.mSromMoments[3], tTolerance);
    EXPECT_NEAR(0.5, tDiagnostics.mTrueMoments[0], tTolerance);
    EXPECT_NEAR(0.375, tDiagnostics.mTrueMoments[1], tTolerance);
    EXPECT_NEAR(0.3125, tDiagnostics.mTrueMoments[2], tTolerance);
    EXPECT_NEAR(0.2734375, tDiagnostics.mTrueMoments[3], tTolerance);
    EXPECT_NEAR(0.099861401416886472, tDiagnostics.mSromCDF[0], tTolerance);
    EXPECT_NEAR(0.29957760047036575, tDiagnostics.mSromCDF[1], tTolerance);
    EXPECT_NEAR(0.49931471064563576, tDiagnostics.mSromCDF[2], tTolerance);
    EXPECT_NEAR(0.69915967725924877, tDiagnostics.mSromCDF[3], tTolerance);
    EXPECT_NEAR(0.24487127477497825, tDiagnostics.mTrueCDF[0], tTolerance);
    EXPECT_NEAR(0.3909744339238192, tDiagnostics.mTrueCDF[1], tTolerance);
    EXPECT_NEAR(0.51924481068784534, tDiagnostics.mTrueCDF[2], tTolerance);
    EXPECT_NEAR(0.66196029192642658, tDiagnostics.mTrueCDF[3], tTolerance);
}

TEST(PlatoTest, solveUncertaintyProblem_beta)
{
    const double tTol = 1e-6;

    // POSE PROBLEM WITH KNOWN SOLUTION
    Plato::UncertaintyInputStruct<double, size_t> tInput;
    tInput.mDistribution = Plato::DistrubtionName::type_t::beta;
    tInput.mMean = 90.;
    tInput.mUpperBound = 135.;
    tInput.mLowerBound = 67.5;
    tInput.mVariance = 135.;
    tInput.mNumSamples = 4;
    tInput.mMaxNumDistributionMoments = 4;

    // SOLVE
    Plato::AlgorithmParamStruct<double, size_t> tParam;
    Plato::SromProblemDiagnosticsStruct<double> tDiagnostics;
    std::vector<Plato::UncertaintyOutputStruct<double>> tOutput;
    Plato::solve_uncertainty(tInput, tParam, tDiagnostics, tOutput);

    // CHECK
    ASSERT_EQ(tOutput.size(), tInput.mNumSamples);
    // GOLD SAMPLES
    EXPECT_NEAR(tOutput[0].mSampleValue, 78.555110973752846, tTol);
    EXPECT_NEAR(tOutput[1].mSampleValue, 95.162418927276619, tTol);
    EXPECT_NEAR(tOutput[2].mSampleValue, 105.76745339378641, tTol);
    EXPECT_NEAR(tOutput[3].mSampleValue, 86.943956034155335, tTol);
    // GOLD PROBABILITIES
    EXPECT_NEAR(tOutput[0].mSampleWeight, 0.2496939761249817, tTol);
    EXPECT_NEAR(tOutput[1].mSampleWeight, 0.24989448275152742, tTol);
    EXPECT_NEAR(tOutput[2].mSampleWeight, 0.25008291182335385, tTol);
    EXPECT_NEAR(tOutput[3].mSampleWeight, 0.24978709886031122, tTol);
    // expect total probability of unity
    const double tTotalProbability = tOutput[0].mSampleWeight + tOutput[1].mSampleWeight + tOutput[2].mSampleWeight
                                     + tOutput[3].mSampleWeight;
    EXPECT_NEAR(tTotalProbability, 0.99945846956017426, tTol);
}

TEST(PlatoTest, solveUncertaintyProblem_uniform)
{
    const double tTol = 1e-6;

    // POSE PROBLEM WITH KNOWN SOLUTION
    Plato::UncertaintyInputStruct<double, size_t> tInput;
    tInput.mDistribution = Plato::DistrubtionName::type_t::uniform;
    tInput.mMean = 0.;
    tInput.mUpperBound = 75.;
    tInput.mLowerBound = 25.;
    tInput.mVariance = 0.;
    tInput.mNumSamples = 5;
    tInput.mMaxNumDistributionMoments = 4;

    // SOLVE
    Plato::AlgorithmParamStruct<double, size_t> tParam;
    Plato::SromProblemDiagnosticsStruct<double> tDiagnostics;
    std::vector<Plato::UncertaintyOutputStruct<double>> tOutput;
    Plato::solve_uncertainty(tInput, tParam, tDiagnostics, tOutput);

    // CHECK
    ASSERT_EQ(tOutput.size(), tInput.mNumSamples);
    // GOLD SAMPLES
    EXPECT_NEAR(tOutput[0].mSampleValue, 33.36670189468537, tTol);
    EXPECT_NEAR(tOutput[1].mSampleValue, 41.700254108657575, tTol);
    EXPECT_NEAR(tOutput[2].mSampleValue, 50.033818262841237, tTol);
    EXPECT_NEAR(tOutput[3].mSampleValue, 58.367394569475238, tTol);
    EXPECT_NEAR(tOutput[4].mSampleValue, 66.700983245423743, tTol);
    // GOLD PROBABILITIES
    EXPECT_NEAR(tOutput[0].mSampleWeight, 0.199629021, tTol);
    EXPECT_NEAR(tOutput[1].mSampleWeight, 0.199696349, tTol);
    EXPECT_NEAR(tOutput[2].mSampleWeight, 0.199829875, tTol);
    EXPECT_NEAR(tOutput[3].mSampleWeight, 0.200029615, tTol);
    EXPECT_NEAR(tOutput[4].mSampleWeight, 0.200295595, tTol);
    // expect total probability of unity
    double tTotalProbability = 0;
    for(size_t tIndex = 0; tIndex < tInput.mNumSamples; tIndex++)
    {
        tTotalProbability += tOutput[tIndex].mSampleWeight;
    }
    EXPECT_NEAR(tTotalProbability, 0.99948045716825895, tTol);
}

TEST(PlatoTest, solveUncertaintyProblem_normal)
{
    const double tTol = 1e-6;

    // POSE PROBLEM WITH KNOWN SOLUTION
    Plato::UncertaintyInputStruct<double, size_t> tInput;
    tInput.mDistribution = Plato::DistrubtionName::type_t::normal;
    tInput.mMean = 90.;
    tInput.mUpperBound = 0.;
    tInput.mLowerBound = 0.;
    tInput.mVariance = 45. * 45.;
    tInput.mNumSamples = 6;
    tInput.mMaxNumDistributionMoments = 5;

    // SOLVE
    Plato::AlgorithmParamStruct<double, size_t> tParam;
    Plato::SromProblemDiagnosticsStruct<double> tDiagnostics;
    std::vector<Plato::UncertaintyOutputStruct<double>> tOutput;
    Plato::solve_uncertainty(tInput, tParam, tDiagnostics, tOutput);

    // CHECK
    ASSERT_EQ(tOutput.size(), tInput.mNumSamples);
    // GOLD SAMPLES
    EXPECT_NEAR(tOutput[0].mSampleValue, 0.,tTol);//0.14289452, tTol);
    EXPECT_NEAR(tOutput[1].mSampleValue, 0.,tTol);//0.28575572, tTol);
    EXPECT_NEAR(tOutput[2].mSampleValue, 0.,tTol);//0.42861694, tTol);
    EXPECT_NEAR(tOutput[3].mSampleValue, 0.,tTol);//0.57147825, tTol);
    EXPECT_NEAR(tOutput[4].mSampleValue, 0.,tTol);//0.71433961, tTol);
    EXPECT_NEAR(tOutput[5].mSampleValue, 0.,tTol);//0.85720098, tTol);
    // GOLD PROBABILITIES
    EXPECT_NEAR(tOutput[0].mSampleWeight, 0.13995699, tTol);
    EXPECT_NEAR(tOutput[1].mSampleWeight, 0.14407919, tTol);
    EXPECT_NEAR(tOutput[2].mSampleWeight, 0.15301207, tTol);
    EXPECT_NEAR(tOutput[3].mSampleWeight, 0.16684967, tTol);
    EXPECT_NEAR(tOutput[4].mSampleWeight, 0.18573693, tTol);
    EXPECT_NEAR(tOutput[5].mSampleWeight, 0.20986992, tTol);
    // expect total probability of unity
    const double tTotalProbability = tOutput[0].mSampleWeight + tOutput[1].mSampleWeight + tOutput[2].mSampleWeight
                                     + tOutput[3].mSampleWeight
                                     + tOutput[4].mSampleWeight
                                     + tOutput[5].mSampleWeight;
    EXPECT_NEAR(tTotalProbability, 0.99950480285612575, tTol);
}

TEST(PlatoTest, OutputSromDiagnostics)
{
    Plato::SromProblemDiagnosticsStruct<double> tDiagnostics;
    tDiagnostics.mCumulativeDistributionFunctionError = 0.01;
    tDiagnostics.mMomentErrors.resize(4);
    tDiagnostics.mMomentErrors[0] = 0.020;
    tDiagnostics.mMomentErrors[1] = 0.021;
    tDiagnostics.mMomentErrors[2] = 0.022;
    tDiagnostics.mMomentErrors[3] = 0.023;
    Plato::output_srom_diagnostics<double, size_t>(tDiagnostics);

    std::ifstream tInputFile;
    tInputFile.open("plato_srom_diagnostics.txt");
    std::string tData;
    std::stringstream tDataFromFile;
    while(tInputFile >> tData)
    {
        tDataFromFile << tData.c_str();
    }
    tInputFile.close();
    std::system("rm -f plato_srom_diagnostics.txt");

    std::stringstream tGold;
    tGold << "PlatoEnginev.1.0:Copyright2018,NationalTechnology&EngineeringSolutionsofSandia,LLC(NTESS).";
    tGold << "CumulativeDistributionFunction(CDF)Mismatch=1.000000e-02--------------------------------|";
    tGold << "StatisticalMomentsMismatch|--------------------------------|NameOrderError|--------------------------------|";
    tGold << "Mean12.000e-02||Variance22.100e-02||Skewness32.200e-02||Kurtosis42.300e-02|--------------------------------";
    ASSERT_STREQ(tDataFromFile.str().c_str(), tGold.str().c_str());
}

} //namespace PlatoTest
